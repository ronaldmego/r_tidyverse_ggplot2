---
title: "tidyverse"
author: "Ronald Mego"
date: "11/20/2021"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, echo=FALSE}}
library(tidyverse)
library(nycflights13)
```

```{r}
?flights
nycflights13::flights
data(flights)
View(flights)
```

#funciones:
filter() -> filtrar observaciones a partir de valores concretos
arrange -> reordenar las filas
select() -> seleccionar variables por sus nombres
mutate() -> crea nuevas variables con funciones a partir de las existentes
summarise() -> colapsar varios valores para dar un resumen de los mismos

group_by() -> opera la función a la que acompaña grupo a grupo

orden de usar las funciones:
1 - dataframe
2 - operaciones que queremos hacer a las variables del dataframe
3 - resultado en un nuevo dataframe

###FILTER: devuelve un dataframe
```{r}
jan1 <- filter ( flights , month == 1 , day == 1 ) #vuelos del 1/1
may19 <-  filter (flights , month == 5 , day == 19 ) #vuelos del 19/5
dec25 <- filter (flights, month == 12 , day == 25 ) #vuelos el 25/12
```


```{r}
filter (flights , month == 5 | month == 6 ) #filtra donde el mes es mayo o junio
filter( flights , month %in% c ( 5 , 6) ) #filtra donde el mes es mayo o junio

filter (flights , arr_delay <= 60 , dep_delay <= 60) #filtra los vuelos cuyo delay de llegada sea maximo de una hora
filter (flights , !(arr_delay>60 | dep_delay>60)) #filtra los vuelos cuyo delay de llegada sea maximo de una hora.usando la ley de morgan
```

```{r}
age.mery<-NA
is.na(age.mery) #como identificar los NA
```

```{r}
df <- tibble (x = c (1,2,NA,4,5)) #data demo con NA
filter(df,is.na(x)|x>2) #subconjunto que incluye el NA
```
```{r}
head(flights) # 6 primeras filas
tail(flights) # 6 ultimas filas
```

#ARRANGE (de menor a mayor)
se visualiza que los datos de "flights" no estan ordenados, entonces los reordenamos:
```{r}
sorted_date <- arrange(flights , year,month,day)
tail(sorted_date)
```

#ARRANGE (de mayor a menor)
```{r}
arrange(flights , desc(arr_delay)) %>% head(.) #el que tuvo mas retraso de partida
arrange(flights, desc(dep_delay)) %>% head(.) #el que tuvo mas retraso de llegada
```

¿Cómo se ordenan los NA? Siempre se van al final
```{r}
arrange(df,x)  #NA se va al final
arrange(df,desc(x)) #NA se va al final
```
```{r}
#el vuelo que mas recorrio
arrange(flights , desc(distance)) %>% head(.) 
```

```{r}
#Encuentra todos los vuelos que llegaron más de una hora tarde de lo previsto.
filter(flights , arr_delay>60) 
```
```{r}
#Encuentra todos los vuelos que volaron hacia San Francisco (aeropuertos SFO y OAK)
filter(flights , dest %in% c("SFO","OAK") ) s
```
```{r}
#Encuentra todos los vuelos operados por United American (UA) o por American Airlines (AA)
filter(flights , carrier %in% c("UA","AA")) 
```

```{r}
#Encuentra todos los vuelos que salieron los meses de primavera (Abril, Mayo y Junio)
filter(flights , month %in% c(4,5,6)) 
```

```{r}
#Encuentra todos los vuelos que llegaron más de una hora tarde pero salieron con menos de una hora de retraso.
filter(flights , dep_delay<60 & arr_delay>60) 
```
```{r}
#Encuentra todos los vuelos que llegaron más de una hora tarde pero salieron con menos de una hora de retraso.
filter ( flights , arr_delay > 60 & dep_delay < 60 ) 
```

```{r}
#Encuentra todos los vuelos que salieron con más de una hora de retraso pero consiguieron llegar con menos de 30 minutos de retraso (el avión aceleró en el aire)
filter ( flights , dep_delay > 60 & arr_delay < 30)
```

```{r}
#Encuentra todos los vuelos que salen entre medianoche y las 7 de la mañana (vuelos nocturnos).
filter ( flights , dep_time > 0000 & dep_time<0700) 
```
```{r}
#Investiga el uso de la función between() de dplyr. ¿Qué hace? Puedes usarlo para resolver la sintaxis necesaria para responder alguna de las preguntas anteriores?

filter ( flights , between( dep_time , 0000 , 0700) ) 
```
```{r}
#¿Cuantos vuelos tienen un valor desconocido de dep_time?
filter( flights , is.na(dep_time))
```
```{r}
#¿Qué variables del dataset contienen valores desconocidos? ¿Qué representan esas filas donde faltan los datos?

colnames(flights)[colSums(is.na(flights)) > 0]
```
```{r}
NA^0
NA|TRUE
FALSE&NA
```
#SELECT

se visualiza que los datos de "flights" no estan ordenados, entonces los reordenamos:
```{r}
sorted_date <- arrange(flights , year,month,day)
```

#como hacer slice de filas
```{r}
sorted_date[1,] #la primera fila
sorted_date[1024:1068,] #las filas desde la posicion 1024 hasta la posicion 1068
```

```{r}
#mostrar solo año, mes y día
select(flights, year, month, day)
```


```{r}
#mostrar solo retraso en tiempo de salida y llegada entre las filas 1024 y la 1068
select ( sorted_date [1024:1068,] , dep_delay, arr_delay)
```

mostrar todas las columnas entre dep_delay y arr_delay
```{r}
select(flights, dep_delay:arr_delay)
```

mostrar todas las columnas excepto las que estan entre año y día
```{r}
select ( flights , -(year:day))
```
mostrar todas las columnas que empiezan por "dep":
```{r}
select ( flights , starts_with("dep"))
```

mostrar todas las columnas que acaban con "delay":
```{r}
select ( flights , ends_with("delay"))
```

mostrar todas las columnas que contengan las letras "st"
```{r}
select ( flights , contains ("st"))
```
seleccionar columnas con expresiones regulares
```{r}
#buscar caracteres repetidos
select( flights , matches ("(.)\\1"))

```
seleccionar columnas que sean x1, x2, x3, x4, x5
```{r}
select ( flights , num_range("x",1:5))
```

seleccionar tres columnas de interes y dejar todas las demas al final con everything:
```{r}
select (flights , time_hour , distance, air_time, everything())
```

```{r}
#¿Qué variables del dataset contienen valores desconocidos? ¿Qué representan esas filas donde faltan los datos?

colnames(flights)[colSums(is.na(flights)) > 0]
```

Piensa cómo podrías usar la función arrange() para colocar todos los valores NA al inicio. Pista: puedes la función is.na() en lugar de la función desc() como argumento de arrange.
```{r}
arrange(flights,!is.na(dep_time)) 

arrange(flights,desc(is.na(dep_delay))) #otra forma
```

Ordena los vuelos de flights para encontrar los vuelos más retrasados en la salida. ¿Qué vuelos fueron los que salieron los primeros antes de lo previsto?
```{r}
arrange(filter(flights,!is.na(dep_delay)),desc(dep_delay))
```
Ordena los vuelos de flights para encontrar los vuelos más retrasados en la salida. ¿Qué vuelos fueron los que salieron los primeros antes de lo previsto?
```{r}
arrange( flights , desc(dep_delay))
```

Ordena los vuelos de flights para encontrar los vuelos más rápidos. Usa el concepto de rapidez que consideres. 
```{r}
arrange(flights, desc (distance/air_time) )
```
¿Qué vuelos tienen los trayectos más largos? Busca en Wikipedia qué dos aeropuertos del dataset alojan los vuelos más largos.
```{r}
arrange(flights , desc(air_time))
```
¿Qué vuelos tienen los trayectos más cortos? Busca en Wikipedia qué dos aeropuertos del dataset alojan los vuelos más largos. 
```{r}
arrange(flights , (air_time))
```
Dale al coco para pensar cuantas más maneras posibles de seleccionar los campos dep_time, dep_delay, arr_time y arr_delay del dataset de flights
```{r}
select(flights, dep_time:arr_delay & -sched_dep_time & -sched_arr_time)
```

Investiga cómo puede ser útil la función one_of() de la pregunta anterior en conjunción con el vector de variables 
#selecciono todas las columnas excepto las que estan en el vector
```{r}
select(flights,-one_of(c("year", "month", "day", "dep_delay", "arr_delay")))
```
```{r}
select(flights, contains("time"))
```
###MUTATE
```{r}
flights_new <- select ( flights , year:day,ends_with("delay"),distance,air_time)
```

#si requieres añadir nuevas variables al dataframe original
```{r}
mutate(flights_new ,
       time_gain = arr_delay - dep_delay,
       air_time_hour= air_time/60,
       flight_speed = distance/air_time_hour,
       time_gain_per_hour = time_gain / air_time_hour
       ) -> flights_new
```
###TRANSMUTE
#si requieres obtener nuevas variables al dataframe original y descartar las antiguas
```{r}
transmute(flights_new ,
       time_gain = arr_delay - dep_delay,
       air_time_hour= air_time/60,
       flight_speed = distance/air_time_hour,
       time_gain_per_hour = time_gain / air_time_hour
       ) -> data_from_flights
```


#Operaciones aritméticas en mutate: +,-,*,/,^
#Agregados de funciones, ejemplos: x/sum(x) | x-mean(x) | (x-mean(x))/sd(x) | (x-min(x))/(max(x)-min(x))
#Aritmetica modular: %/% -> cociente de la division entera, && -> resto de la division entera
#ejemplo: x==y*(x%/%y) + (x%%y)s 
```{r}
transmute(flights,
          air_time,
          hour_air = air_time%/% 60,
          minute_air= air_time %%60
          )
```
#logaritmos: log() -> logarimto en base e, log2(), log10()
#offsetgs: lead(), 
# lag() -> mueve hacia la derecha
# lead() -> mueve hacia la izquierda
```{r}
df <- 1:12
df
lag(df)
lead(df)
```

#Funciones acumulativas: cumsum(), cumprod(), cummin(), cummax(), cummean()
```{r}
df
cumsum(df)
cumprod(df)
cummin(df)
cummax(df)
cummean(df)
```
#comparaciones logicas: >,>=,<,<=,==,!=
```{r}
transmute(flights,
          dep_delay,
          has_been_delayed=(dep_delay>0)
          )
```

#Rankings: min_rank() , esta funcion podria tener empates
```{r}
df <- c(7,1,2,5,3,3,NA,3,4,-2)
df
min_rank(df) #de menor a mayor
min_rank(desc(df)) #de mayor a menor
```

#Rankings: row_number() , esta funcion no tiene empates
```{r}
df
row_number(df)
```

```{r}
df
dense_rank(df)
```
#porcentaje relativo sore el mas grande
```{r}
df
percent_rank(df)
```

#porcentaje acumulado
```{r}
df
cume_dist(df)
```
#quantiles: indica a que quantil pertenece cada dato
```{r}
df
ntile(df,n=4)
```

